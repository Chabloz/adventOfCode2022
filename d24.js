let input = `#.########################################################################################################################
#<^>^<^^<v><vv^v^<^vv>^<^v>vv^v<<v<>^>^v<>v<<<.^<>^>v^><v<^...>>>>.^>>>v<.^^^^^>.v.v<v.><^<v<<v<>.<v.v<><vv.v>v>v<<<<<.<<#
#<>^^^v<.v<<v.v.vv.v^v>v<>.>vv>^>vv>^^><<<v>><v>><>.v.v>><><<>>vv>^^v<v^v><^<.><vv<.v<v>^^<v>^>^>^<v<>.<^.^<.>^v<<<<v^^.>#
#<v..^^>><<vvv><v^><>.>^^^><<>^><>>>^v<>><>^<v<<>>>v^v>.^v<v^>><vvv^<<.><v<.v<^>.v<..>^^^>><^v<v<v>v><>>>vvv^<<^v^>v.^v^<#
#<.^vv<^<.>>>>v<v^vv^v.v.v>>>^v<<<v^^<v<^<>.v<><v.v^<<^><><v^<<v.>><v><vv>^.<^<^v.v>>vv<>>vv^.^.><vv<^^^^<v^v<v>vv.v.><v>#
#<><^>v.^<v^<vv>vvv>>^v<v..vv.><>^>^v<<v.<v^...vv>>><^<^<^>v^^^><v<^<v<^.^<.^v><<v<.<>^<>v^.<>>.><^<^><><vv>vv^vv>><<><.<#
#.^^^^^^v^v.<<><>vv<>.>^v<v>^>.<>v.^^<><>^<>^v^^.<v<vv>>v<^<^><v<>.<v>^<^vvv<>^<^v^^.>.^.><<>v>v^>^^>vv^v>v.^vv<v^>>^^v><#
#<<^<<v>^<v^>>>v><^.^<.<>^.><v>vv<<.>v<^^v>vv>>>^<<>^<v<v<^<^.^^<><<<<^>v^>vv>^vv^v<.>v^^vv^<v^<v><>><v^<>^v<v><vv>^.<^v<#
#<<>.v^<v>^<>>v><<><vvvvv^><<<<>^<.<<>><^<v>>^<<^.v<<.>>><v<^.v.v<<v>>^><^v<>><^>>v>>>.^>>v^<^.<v>vv..v^^vvv^vv<>^<v<<>.>#
#><.v.^><vv.>>>>><.>.vv^<<>v><^<<v.<><>.v<v><<.>>v>>v<^.^^^<^^<v>^^<<>>><^>><^>^<.<v^v<v^><v<.<^^.>>^^<v.v<><v<>^^<.^<>v>#
#<<>v<^<.<<.>vv<.><>.vvvv<^.<<>><<v>>^^>v>^v>v<^^v.<^v<>vv^<><<>vv<v<^^<<><v>^<vv.^<>v<>.><vv>>vv^.>.>v>v>^v>^.><v<.v><^>#
#>.>>vv>><<>^v^^v>^<<.^^>>><v<v>>><<^^^<^vv<>v<v^>.<^<^<>v<^><>v.v^.>>v^^^^>.v.><v^^^vv<^>v^.^>v<>v.^^.^^v^v<v>>.^><<.^<>#
#<>v.^>>>>^^^>v<^<>v>^>v>vv^^>v.v<>>.>^><<>v^v.<v>^..v.>vv.^>^^v<v^^v>vvvvv>>^<^v.<>><<.v^>vv>>>vv><^.><.<^^^v^>^v<>v<v^>#
#<^<v^.>>.^<^^v^v.<v<<vv^.^.><vv^vv<>v^>.<.<<^<vv^>><<^^v^v^<v^vv.^^^>vv^<>v^>v^vv<>v.^v.<>^>vv>.^<^.v.>v>v>>v<v<^v>><v<<#
#>.<<>^^vvv>>v^^>^<^>.<<.v^>vv>>v<vv<<^v.<.v^^^.^>v>>.>>.^<<^v>.vvv><<<>^.^v>vvv^^^^<vv.><v<>v<<<><^^<v<.><<^><<>><><v^<<#
#<<<<..^v>v^>v^>^.<<^<>>v.vv>>>^^v^.vv^>><<<<.<<>^>^v>><>.>><>^><v^<v<^^v^>^>^^>>v>^>v.<v>>^<<^><<v>^v^<>v<>^^>>v<vv^vv>.#
#..^>^v.>.<^>^>.v>>.<<..<<>v^vvv<<vvv<.<>v><.<^^>^<^^<^>><>^<.vv<<<>^^v^><><^<^vv<<.<<v^^v^<<vv^<.v>^>v.v<^^<>>>.>^^v<^v>#
#<.>vv<.<>^<<.>.v<<><vvv^<<v>><<.>.vv^^<>vv^v..^<>>.^<>^>^^<^^^<v^>>>><><>^^.vv<<>v>^.v.^^<<^v<>.^>>^^>v>v^^^>v^>^>><v>><#
#<>v>vv<<<><<v><<v>v>>^.<vvvv<^^<^<>^<<^>>^^>^v.<vv^vv<>v^<>^^<>>^v.>.<.>>>.<<^><.<^^>^>>.><^>.^>v<^>^>v>.^^v>.v^>>>>>v>>#
#<.<<^>><<^>.v>v^^.v^>v<^<vv^>>>^.>>>^>^v<^v<v>.>^^<<<>v.^.v^v.^>.<v<<v^^^<<><>^><<<<>v^^><v^<>..>v.><^^.<<<^.>^<>>>vv><>#
#>^v.>vvv^^.^<>^><vv>^>v^<>.^.v<v>.^v<<v^^>^v><^v<>^>>v.^<^><<>^>>>><^^<v<<><<>^^><<<^vvv>><.<v>^>>v^^<^><>.<v^>>..^^v>v>#
#.<^^><<<^^^v<>^.>v>v^><v<>v^^.v^.^<<<^^<vvv^<^^v.<vvv<>v.v^<^>.<>><<><^v^v.^^<>^v^vvvv><<^^><<>vv<v^v^.^v<<<^v<<<^<v>v^>#
#.<^..v^^^>>^v^^.><v><>v^.>v^^<<><^^<.<>>v^>.<>>.^>vv>v>^v.<^^^<<^<vv>.^>^.<<<.^^>.^^^.v<<>v<.vv^^<>v>>>><>^>^^.<<^^<>><<#
#<^<^^>>^.<v>^^^>v><^><.v>>v^>vv>v.>^>^<^^^^v<<<^>.>v^<v.<v^^^^>v^..<<<<>^<<<>^<v^^>^vv^v>.<^v<><>^<<>^<>>v>><<>^>vvvv<>>#
#>>^.^^<v<<vvv^^<<vv>>^^<<>^^vv>>><v>^>v<v>v.><><^^v<<<.<vv>v<^^>><^v>^<>^<v<vv<v^>v<^.<<>^v<.^<.v.><.<^>^vvvvvv^v^^<^.<>#
#<><<^<.<^>^^^<v>.^v>>vv.vv<v..<^vv<>.^vv^.^<vv<>^vvv<v^>v.<v<v<.^>.<.v^>^>>>vv<>^>.>>^^^<<^v<^.vv>>v.v<v><<<^^^v^vvv..^>#
########################################################################################################################.#`;

function parseInput(input) {
  // Get the grid without the walls enclosing it
  const grid = input.split('\n').map(row => [...row].filter(c => c != '#'));
  grid.shift();
  grid.pop();
  const start = {row: 0, col: 0};
  const destination = {row: grid.length - 1, col: grid[0].length - 1};
  // Amount of simulation steps needed to simulated all the blizzards possible positions
  const maxSimulationTime = Math.max(grid.length, grid[0].length) * 20;
  return {grid, start, destination, maxSimulationTime};
}

function moduloEuclidian(op1, op2) {
  return ((op1 % op2) + op2) % op2;
}

class BlizzardAutomaton {
  air = '.';
  north = '^';
  east = '>';
  south = 'v';
  west = '<';

  constructor(grid) {
    this.grid = grid;
    this.maxRow = this.grid.length - 1;
    this.maxCol = this.grid[0].length - 1;
  }

  getCell({row, col}) {
    return this.grid[row][col];
  }

  hash({row, col}) {
    return `${row}:${col}`;
  }

  hashWithTime({row, col, time}) {
    return `${row}:${col}:${time}`;
  }

  getPositionAtTime(dir, row, col, time) {
    if (dir == this.north) {
      row = moduloEuclidian(row - time, this.maxRow + 1);
    } else if (dir == this.east) {
      col = moduloEuclidian(col + time, this.maxCol + 1);
    } else if (dir == this.south) {
      row = moduloEuclidian(row + time, this.maxRow + 1);
    } else if (dir == this.west) {
      col = moduloEuclidian(col - time, this.maxCol + 1);
    }
    return {row, col};
  }

  positionAtTime(time) {
    const positions = new Set();
    for (let row = 0; row <= this.maxRow; row++) {
      for (let col = 0; col <= this.maxCol; col++) {
        const dir = this.getCell({row, col});
        // only blizzard cells have direction
        if (dir == this.air) continue;
        const pos = this.getPositionAtTime(dir, row, col, time);
        positions.add(this.hash(pos));
      }
    }
    return positions;
  }

  getTimePositionsMap(maxSimulationTime) {
    const positionsAtTime = new Map();
    for (let time = 0; time <= maxSimulationTime; time++) {
      positionsAtTime.set(time, this.positionAtTime(time));
    }
    return positionsAtTime;
  }

  isValidPosition({row, col}) {
    return row >= 0 && row <= this.maxRow && col >= 0 && col <= this.maxCol;
  }

  // Get the Von Neumann neighborhood of a cell with the cell itself
  getVonNeumannNeighborhood({row, col}) {
    return [
      {row, col},
      {row: row - 1, col},
      {row: row + 1, col},
      {row, col: col - 1},
      {row, col: col + 1},
    ].filter(pos => this.isValidPosition(pos));
  }

  getTimeToReach(start, destination, maxSimulationTime, actualTime = 0) {
    const blizzardsPositions = this.getTimePositionsMap(maxSimulationTime);

    let time = actualTime;

    const visited = new Set();
    const frontier = [];
    frontier.push({...start, time});

    while (frontier.length > 0) {
      const current = frontier.shift();

      // If the destination is reached, return the time taken to reach it
      if (current.row == destination.row && current.col == destination.col) return current.time;

      // If allready visited, skip
      const hash = this.hashWithTime(current);
      if (visited.has(hash)) continue;

      visited.add(hash);

      // Explore the neighborhood
      const neighbors = this.getVonNeumannNeighborhood(current);

      for (const neighbor of neighbors) {
        // Ignore it if a blizzard is present
        if (blizzardsPositions.get(current.time + 1).has(this.hash(neighbor))) continue;
        frontier.push({...neighbor, time: current.time + 1});
      }
    }
    // retry (if the entrance was a blizzard or no possible path for this time)
    return this.getTimeToReach(start, destination, maxSimulationTime, actualTime + 1);
  }
}

// part 1
const {grid, start, destination, maxSimulationTime} = parseInput(input);
let automaton = new BlizzardAutomaton(grid);
let time = automaton.getTimeToReach(start, destination, maxSimulationTime);
console.log(time + 1);

// part 2
time = automaton.getTimeToReach(destination, start, maxSimulationTime, time + 1);
time = automaton.getTimeToReach(start, destination, maxSimulationTime, time + 1);
console.log(time + 1);